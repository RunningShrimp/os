name: Generate Issues From Todo
on:
  workflow_dispatch:
permissions:
  contents: read
  issues: write
jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Create issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = '.trae/documents/Rust 操作系统内核项目实施计划与Todo.md';
            const exists = fs.existsSync(path);
            if (!exists) {
              core.setFailed('Todo document not found: ' + path);
              return;
            }
            const content = fs.readFileSync(path, 'utf8');
            const lines = content.split('\n');
            let start = lines.findIndex(l => l.trim().startsWith('## Todo'));
            if (start < 0) {
              core.setFailed('Todo section not found');
              return;
            }
            const todos = [];
            for (let i = start + 1; i < lines.length; i++) {
              const t = lines[i].trim();
              if (t.startsWith('- ')) {
                todos.push(t.slice(2).trim());
              }
            }
            if (todos.length === 0) {
              core.info('No todos found');
              return;
            }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const labelNames = ['todo','area:posix','area:perf','area:fs','area:net','area:smp','area:docs','area:maint'];
            const existingLabels = await github.paginate(github.rest.issues.listLabelsForRepo, { owner, repo, per_page: 100 });
            const existing = new Set(existingLabels.map(l => l.name));
            for (const name of labelNames) {
              if (!existing.has(name)) {
                await github.rest.issues.createLabel({ owner, repo, name, color: 'ededed' });
              }
            }
            function inferLabels(title) {
              const ls = ['todo'];
              const t = title.toLowerCase();
              if (t.includes('posix') || t.includes('syscall')) ls.push('area:posix');
              if (t.includes('microbench') || t.includes('性能') || t.includes('i/o') || t.includes('调度')) ls.push('area:perf');
              if (t.includes('文件系统') || t.includes('路径')) ls.push('area:fs');
              if (t.includes('网络') || t.includes('socket')) ls.push('area:net');
              if (t.includes('smp') || t.includes('锁')) ls.push('area:smp');
              if (t.includes('文档') || t.includes('示例')) ls.push('area:docs');
              if (t.includes('错误') || t.includes('crate') || t.includes('工作区')) ls.push('area:maint');
              return ls;
            }
            const created = [];
            for (const title of todos) {
              const labels = inferLabels(title);
              const body = [
                `来源: ${path}`,
                `条目: ${title}`,
                '',
                '验收标准:',
                '- 行为一致性与测试覆盖达标',
                '- 性能基线无回归或达成目标',
                '- 文档与示例完善',
                '',
                '子任务:',
                '- [ ] 设计与接口评审',
                '- [ ] 实现与单元测试',
                '- [ ] 基准与性能验证',
                '- [ ] 文档与示例补充'
              ].join('\n');
              const issue = await github.rest.issues.create({ owner, repo, title: `[Todo] ${title}`, body, labels });
              created.push(issue.data.number);
            }
            core.summary.addHeading('Todo Issues Created');
            for (const n of created) {
              core.summary.addRaw(`#${n}\n`);
            }
            await core.summary.write();
