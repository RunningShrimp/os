//! Graphics Backend - Infrastructure abstraction for display output
//!
//! Provides platform-independent graphics interface and concrete implementations
//! for UEFI GOP and BIOS VBE graphics systems.

use alloc::boxed::Box;
use crate::domain::boot_config::GraphicsMode;
use crate::protocol::FramebufferInfo;

/// Framebuffer pixel format
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PixelFormat {
    RGB,
    BGR,
    ARGB,
    ABGR,
}

/// Graphics backend trait - Platform-independent graphics interface
///
/// Implementations provide graphics functionality for different boot protocols
/// (UEFI GOP, BIOS VBE, ARM framebuffer, etc.)
pub trait GraphicsBackend: Send + Sync {
    /// Initialize graphics backend with specified mode
    ///
    /// # Arguments
    /// * `mode` - Desired graphics mode
    ///
    /// # Returns
    /// Framebuffer information if successful
    fn initialize(&mut self, mode: &GraphicsMode) -> Result<FramebufferInfo, &'static str>;

    /// Get framebuffer address
    fn get_framebuffer_addr(&self) -> Option<usize>;

    /// Get current framebuffer info
    fn get_framebuffer_info(&self) -> Option<FramebufferInfo>;

    /// Clear entire screen to color
    fn clear_screen(&mut self, color: u32) -> Result<(), &'static str>;

    /// Draw single pixel
    fn draw_pixel(&mut self, x: u32, y: u32, color: u32) -> Result<(), &'static str>;

    /// Draw text at position
    fn draw_text(&mut self, x: u32, y: u32, text: &str, color: u32) -> Result<(), &'static str>;

    /// Present framebuffer (swap buffers)
    fn swap_buffers(&mut self) -> Result<(), &'static str>;

    /// Check if backend supports specified mode
    fn supports_mode(&self, mode: &GraphicsMode) -> bool;

    /// Get pixel format of framebuffer
    fn pixel_format(&self) -> PixelFormat;
}

/// UEFI GOP Backend - Graphics Output Protocol implementation
#[cfg(feature = "uefi_support")]
pub struct UefiGopBackend {
    framebuffer_info: Option<FramebufferInfo>,
    initialized: bool,
}

#[cfg(feature = "uefi_support")]
impl UefiGopBackend {
    pub fn new() -> Self {
        Self {
            framebuffer_info: None,
            initialized: false,
        }
    }
}

#[cfg(feature = "uefi_support")]
impl GraphicsBackend for UefiGopBackend {
    fn initialize(&mut self, mode: &GraphicsMode) -> Result<FramebufferInfo, &'static str> {
        // In real implementation, would call UEFI GOP protocol
        // For now, create a framebuffer descriptor
        if !self.supports_mode(mode) {
            return Err("UEFI GOP does not support requested mode");
        }

        let fb_info = FramebufferInfo {
            address: 0xF0000000,  // Test framebuffer address (would be set by UEFI GOP in real implementation)
            width: mode.width as u32,
            height: mode.height as u32,
            pitch: mode.scanline_bytes() as u32,
            bpp: mode.bits_per_pixel as u32,
        };

        self.framebuffer_info = Some(fb_info.clone());
        self.initialized = true;

        Ok(fb_info)
    }

    fn get_framebuffer_addr(&self) -> Option<usize> {
        self.framebuffer_info.as_ref().map(|fb| fb.address)
    }

    fn get_framebuffer_info(&self) -> Option<FramebufferInfo> {
        self.framebuffer_info.clone()
    }

    fn clear_screen(&mut self, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        if let Some(fb_info) = &self.framebuffer_info {
            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;
            let total_pixels = stride_pixels * fb_info.height as usize;

            // SAFETY: Assumes framebuffer address is valid
            unsafe {
                let fb_slice = core::slice::from_raw_parts_mut(fb_ptr, total_pixels);
                fb_slice.fill(color);
            }
        }

        Ok(())
    }

    fn draw_pixel(&mut self, x: u32, y: u32, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        if let Some(fb_info) = &self.framebuffer_info {
            if x >= fb_info.width || y >= fb_info.height {
                return Err("Pixel coordinates out of bounds");
            }

            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;
            let offset = (y as usize * stride_pixels) + x as usize;

            // SAFETY: Assumes framebuffer address is valid and coordinates are within bounds
            unsafe {
                fb_ptr.add(offset).write(color);
            }
        }

        Ok(())
    }

    fn draw_text(&mut self, x: u32, y: u32, text: &str, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        // Simple text rendering implementation (8x8 font)
        if let Some(fb_info) = &self.framebuffer_info {
            let char_width = 8;
            let char_height = 8;

            // Basic font data for ASCII characters 32-126
            let font_data = [
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Space (32)
                0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, // ! (33)
                0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, // " (34)
                0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00, 0x00, // # (35)
                0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00, 0x00, // $ (36)
                0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, // % (37)
                0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, // & (38)
                0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, // ' (39)
                0x00, 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00, 0x00, // ( (40)
                0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, // ) (41)
                0x00, 0x08, 0x2a, 0x1c, 0x2a, 0x08, 0x00, 0x00, // * (42)
                0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, // + (43)
                0x00, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00, 0x00, // , (44)
                0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, // - (45)
                0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, // . (46)
                0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, // / (47)
                0x00, 0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00, 0x00, // 0 (48)
                0x00, 0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x00, // 1 (49)
                0x00, 0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, // 2 (50)
                0x00, 0x21, 0x41, 0x45, 0x4b, 0x31, 0x00, 0x00, // 3 (51)
                0x00, 0x18, 0x14, 0x12, 0x7f, 0x10, 0x00, 0x00, // 4 (52)
                0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, // 5 (53)
                0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00, 0x00, // 6 (54)
                0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, // 7 (55)
                0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, // 8 (56)
                0x00, 0x06, 0x49, 0x49, 0x29, 0x1e, 0x00, 0x00, // 9 (57)
                0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, // : (58)
                0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, // ; (59)
                0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, // < (60)
                0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, // = (61)
                0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, // > (62)
                0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, // ? (63)
                0x00, 0x3e, 0x41, 0x5d, 0x59, 0x4e, 0x00, 0x00, // @ (64)
                0x00, 0x7c, 0x12, 0x11, 0x12, 0x7c, 0x00, 0x00, // A (65)
                0x00, 0x7f, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, // B (66)
                0x00, 0x3e, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, // C (67)
                0x00, 0x7f, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, // D (68)
                0x00, 0x7f, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, // E (69)
                0x00, 0x7f, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, // F (70)
                0x00, 0x3e, 0x41, 0x49, 0x49, 0x3a, 0x00, 0x00, // G (71)
                0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00, 0x00, // H (72)
                0x00, 0x00, 0x41, 0x7f, 0x41, 0x00, 0x00, 0x00, // I (73)
                0x00, 0x20, 0x40, 0x41, 0x3f, 0x01, 0x00, 0x00, // J (74)
                0x00, 0x7f, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, // K (75)
                0x00, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, // L (76)
                0x00, 0x7f, 0x02, 0x04, 0x02, 0x7f, 0x00, 0x00, // M (77)
                0x00, 0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00, 0x00, // N (78)
                0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00, 0x00, // O (79)
                0x00, 0x7f, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, // P (80)
                0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00, 0x00, // Q (81)
                0x00, 0x7f, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, // R (82)
                0x00, 0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, // S (83)
                0x00, 0x01, 0x01, 0x7f, 0x01, 0x01, 0x00, 0x00, // T (84)
                0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00, 0x00, // U (85)
                0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00, 0x00, // V (86)
                0x00, 0x3f, 0x40, 0x38, 0x40, 0x3f, 0x00, 0x00, // W (87)
                0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, // X (88)
                0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, // Y (89)
                0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, // Z (90)
                0x00, 0x00, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00, // [ (91)
                0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, // \ (92)
                0x00, 0x00, 0x41, 0x41, 0x7f, 0x00, 0x00, 0x00, // ] (93)
                0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, // ^ (94)
                0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, // _ (95)
                0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, // ` (96)
                0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, // a (97)
                0x00, 0x7f, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, // b (98)
                0x00, 0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, // c (99)
                0x00, 0x38, 0x44, 0x44, 0x48, 0x7f, 0x00, 0x00, // d (100)
                0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, // e (101)
                0x00, 0x08, 0x7e, 0x09, 0x01, 0x02, 0x00, 0x00, // f (102)
                0x00, 0x0c, 0x52, 0x52, 0x52, 0x3e, 0x00, 0x00, // g (103)
                0x00, 0x7f, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, // h (104)
                0x00, 0x00, 0x44, 0x7d, 0x40, 0x00, 0x00, 0x00, // i (105)
                0x00, 0x40, 0x80, 0x84, 0x7d, 0x00, 0x00, 0x00, // j (106)
                0x00, 0x7f, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, // k (107)
                0x00, 0x00, 0x41, 0x7f, 0x40, 0x00, 0x00, 0x00, // l (108)
                0x00, 0x7c, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, // m (109)
                0x00, 0x7c, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, // n (110)
                0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, // o (111)
                0x00, 0xfc, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00, // p (112)
                0x00, 0x18, 0x24, 0x24, 0x18, 0xfc, 0x00, 0x00, // q (113)
                0x00, 0x7c, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, // r (114)
                0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, // s (115)
                0x00, 0x04, 0x3f, 0x44, 0x40, 0x20, 0x00, 0x00, // t (116)
                0x00, 0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00, 0x00, // u (117)
                0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00, 0x00, // v (118)
                0x00, 0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00, 0x00, // w (119)
                0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, // x (120)
                0x00, 0x0c, 0x50, 0x50, 0x50, 0x3c, 0x00, 0x00, // y (121)
                0x00, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x00, 0x00, // z (122)
                0x00, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, // { (123)
                0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, // | (124)
                0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, // } (125)
                0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x00, // ~ (126)
            ];

            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;

            for (i, c) in text.chars().enumerate() {
                let ascii_code = c as u8;
                if ascii_code < 32 || ascii_code > 126 {
                    continue; // Skip non-printable ASCII characters
                }

                let char_x = x + (i as u32 * char_width);
                if char_x >= fb_info.width {
                    break; // Stop if we reach the right edge
                }

                let font_offset = ((ascii_code - 32) as usize) * char_height;

                // Draw each pixel of the character
                for dy in 0..char_height {
                    let row_y = y + dy as u32;
                    if row_y >= fb_info.height {
                        break; // Stop if we reach the bottom
                    }

                    let font_row = font_data[font_offset + dy as usize];

                    for dx in 0..char_width {
                        let pixel_x = char_x + dx;
                        if pixel_x >= fb_info.width {
                            break;
                        }

                        if (font_row >> (7 - dx)) & 1 != 0 {
                            let pixel_offset = (row_y as usize * stride_pixels) + pixel_x as usize;

                            // SAFETY: Assumes framebuffer address is valid and coordinates are within bounds
                            unsafe {
                                fb_ptr.add(pixel_offset).write(color);
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    fn swap_buffers(&mut self) -> Result<(), &'static str> {
        // GOP doesn't typically need buffer swapping
        Ok(())
    }

    fn supports_mode(&self, mode: &GraphicsMode) -> bool {
        // GOP supports wide range of modes
        mode.width >= 640 && mode.width <= 4096
            && mode.height >= 480 && mode.height <= 2160
    }

    fn pixel_format(&self) -> PixelFormat {
        PixelFormat::BGR  // GOP typically uses BGR
    }
}

/// BIOS VBE Backend - VESA BIOS Extensions implementation
#[cfg(feature = "bios_support")]
pub struct VbeBackend {
    framebuffer_info: Option<FramebufferInfo>,
    initialized: bool,
    vbe_controller: crate::graphics::vbe::VbeGraphicsManager,
}

#[cfg(feature = "bios_support")]
impl VbeBackend {
    pub fn new() -> Self {
        Self {
            framebuffer_info: None,
            initialized: false,
            vbe_controller: crate::graphics::vbe::VbeGraphicsManager::new(),
        }
    }
}

#[cfg(feature = "bios_support")]
impl GraphicsBackend for VbeBackend {
    fn initialize(&mut self, mode: &GraphicsMode) -> Result<FramebufferInfo, &'static str> {
        if !self.supports_mode(mode) {
            return Err("VBE does not support requested mode");
        }

        // Initialize VBE controller
        if let Err(_) = self.vbe_controller.initialize() {
            return Err("Failed to initialize VBE controller");
        }

        // Set graphics mode using VBE controller
        let width = mode.width as u16;
        let height = mode.height as u16;
        let bpp = mode.bits_per_pixel as u8;

        if let Err(_) = self.vbe_controller.set_mode(width, height, bpp) {
            return Err("Failed to set VBE graphics mode");
        }

        // Get real framebuffer info from VBE controller
        let fb_info = match self.vbe_controller.get_framebuffer_info() {
            Some(info) => info.clone(),
            None => return Err("Failed to get framebuffer info"),
        };

        self.framebuffer_info = Some(fb_info.clone());
        self.initialized = true;

        Ok(fb_info)
    }

    fn get_framebuffer_addr(&self) -> Option<usize> {
        self.framebuffer_info.as_ref().map(|fb| fb.address)
    }

    fn get_framebuffer_info(&self) -> Option<FramebufferInfo> {
        self.framebuffer_info.clone()
    }

    fn clear_screen(&mut self, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        if let Some(fb_info) = &self.framebuffer_info {
            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;
            let total_pixels = stride_pixels * fb_info.height as usize;

            // SAFETY: Assumes framebuffer address is valid
            unsafe {
                let fb_slice = core::slice::from_raw_parts_mut(fb_ptr, total_pixels);
                fb_slice.fill(color);
            }
        }

        Ok(())
    }

    fn draw_pixel(&mut self, x: u32, y: u32, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        if let Some(fb_info) = &self.framebuffer_info {
            if x >= fb_info.width || y >= fb_info.height {
                return Err("Pixel coordinates out of bounds");
            }

            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;
            let offset = (y as usize * stride_pixels) + x as usize;

            // SAFETY: Assumes framebuffer address is valid and coordinates are within bounds
            unsafe {
                fb_ptr.add(offset).write(color);
            }
        }

        Ok(())
    }

    fn draw_text(&mut self, x: u32, y: u32, text: &str, color: u32) -> Result<(), &'static str> {
        if !self.initialized {
            return Err("Graphics not initialized");
        }

        // Simple text rendering implementation (8x8 font)
        if let Some(fb_info) = &self.framebuffer_info {
            let char_width = 8;
            let char_height = 8;

            // Basic font data for ASCII characters 32-126
            let font_data = [
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Space (32)
                0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, // ! (33)
                0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, // " (34)
                0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00, 0x00, // # (35)
                0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00, 0x00, // $ (36)
                0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, // % (37)
                0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, // & (38)
                0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, // ' (39)
                0x00, 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00, 0x00, // ( (40)
                0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, // ) (41)
                0x00, 0x08, 0x2a, 0x1c, 0x2a, 0x08, 0x00, 0x00, // * (42)
                0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, // + (43)
                0x00, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00, 0x00, // , (44)
                0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, // - (45)
                0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, // . (46)
                0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, // / (47)
                0x00, 0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00, 0x00, // 0 (48)
                0x00, 0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x00, // 1 (49)
                0x00, 0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, // 2 (50)
                0x00, 0x21, 0x41, 0x45, 0x4b, 0x31, 0x00, 0x00, // 3 (51)
                0x00, 0x18, 0x14, 0x12, 0x7f, 0x10, 0x00, 0x00, // 4 (52)
                0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, // 5 (53)
                0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00, 0x00, // 6 (54)
                0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, // 7 (55)
                0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, // 8 (56)
                0x00, 0x06, 0x49, 0x49, 0x29, 0x1e, 0x00, 0x00, // 9 (57)
                0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, // : (58)
                0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, // ; (59)
                0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, // < (60)
                0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, // = (61)
                0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, // > (62)
                0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, // ? (63)
                0x00, 0x3e, 0x41, 0x5d, 0x59, 0x4e, 0x00, 0x00, // @ (64)
                0x00, 0x7c, 0x12, 0x11, 0x12, 0x7c, 0x00, 0x00, // A (65)
                0x00, 0x7f, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, // B (66)
                0x00, 0x3e, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, // C (67)
                0x00, 0x7f, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, // D (68)
                0x00, 0x7f, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, // E (69)
                0x00, 0x7f, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, // F (70)
                0x00, 0x3e, 0x41, 0x49, 0x49, 0x3a, 0x00, 0x00, // G (71)
                0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00, 0x00, // H (72)
                0x00, 0x00, 0x41, 0x7f, 0x41, 0x00, 0x00, 0x00, // I (73)
                0x00, 0x20, 0x40, 0x41, 0x3f, 0x01, 0x00, 0x00, // J (74)
                0x00, 0x7f, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, // K (75)
                0x00, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, // L (76)
                0x00, 0x7f, 0x02, 0x04, 0x02, 0x7f, 0x00, 0x00, // M (77)
                0x00, 0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00, 0x00, // N (78)
                0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00, 0x00, // O (79)
                0x00, 0x7f, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, // P (80)
                0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00, 0x00, // Q (81)
                0x00, 0x7f, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, // R (82)
                0x00, 0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, // S (83)
                0x00, 0x01, 0x01, 0x7f, 0x01, 0x01, 0x00, 0x00, // T (84)
                0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00, 0x00, // U (85)
                0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00, 0x00, // V (86)
                0x00, 0x3f, 0x40, 0x38, 0x40, 0x3f, 0x00, 0x00, // W (87)
                0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, // X (88)
                0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, // Y (89)
                0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, // Z (90)
                0x00, 0x00, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00, // [ (91)
                0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, // \ (92)
                0x00, 0x00, 0x41, 0x41, 0x7f, 0x00, 0x00, 0x00, // ] (93)
                0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, // ^ (94)
                0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, // _ (95)
                0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, // ` (96)
                0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, // a (97)
                0x00, 0x7f, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, // b (98)
                0x00, 0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, // c (99)
                0x00, 0x38, 0x44, 0x44, 0x48, 0x7f, 0x00, 0x00, // d (100)
                0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, // e (101)
                0x00, 0x08, 0x7e, 0x09, 0x01, 0x02, 0x00, 0x00, // f (102)
                0x00, 0x0c, 0x52, 0x52, 0x52, 0x3e, 0x00, 0x00, // g (103)
                0x00, 0x7f, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, // h (104)
                0x00, 0x00, 0x44, 0x7d, 0x40, 0x00, 0x00, 0x00, // i (105)
                0x00, 0x40, 0x80, 0x84, 0x7d, 0x00, 0x00, 0x00, // j (106)
                0x00, 0x7f, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, // k (107)
                0x00, 0x00, 0x41, 0x7f, 0x40, 0x00, 0x00, 0x00, // l (108)
                0x00, 0x7c, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, // m (109)
                0x00, 0x7c, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, // n (110)
                0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, // o (111)
                0x00, 0xfc, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00, // p (112)
                0x00, 0x18, 0x24, 0x24, 0x18, 0xfc, 0x00, 0x00, // q (113)
                0x00, 0x7c, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, // r (114)
                0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, // s (115)
                0x00, 0x04, 0x3f, 0x44, 0x40, 0x20, 0x00, 0x00, // t (116)
                0x00, 0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00, 0x00, // u (117)
                0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00, 0x00, // v (118)
                0x00, 0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00, 0x00, // w (119)
                0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, // x (120)
                0x00, 0x0c, 0x50, 0x50, 0x50, 0x3c, 0x00, 0x00, // y (121)
                0x00, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x00, 0x00, // z (122)
                0x00, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, // { (123)
                0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, // | (124)
                0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, // } (125)
                0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x00, // ~ (126)
            ];

            let fb_ptr = fb_info.address as *mut u32;
            let stride_pixels = (fb_info.pitch / 4) as usize;

            for (i, c) in text.chars().enumerate() {
                let ascii_code = c as u8;
                if ascii_code < 32 || ascii_code > 126 {
                    continue; // Skip non-printable ASCII characters
                }

                let char_x = x + (i as u32 * char_width);
                if char_x >= fb_info.width {
                    break; // Stop if we reach the right edge
                }

                let font_offset = ((ascii_code - 32) as usize) * char_height;

                // Draw each pixel of the character
                for dy in 0..char_height {
                    let row_y = y + dy as u32;
                    if row_y >= fb_info.height {
                        break; // Stop if we reach the bottom
                    }

                    let font_row = font_data[font_offset + dy as usize];

                    for dx in 0..char_width {
                        let pixel_x = char_x + dx;
                        if pixel_x >= fb_info.width {
                            break;
                        }

                        if (font_row >> (7 - dx)) & 1 != 0 {
                            let pixel_offset = (row_y as usize * stride_pixels) + pixel_x as usize;

                            // SAFETY: Assumes framebuffer address is valid and coordinates are within bounds
                            unsafe {
                                fb_ptr.add(pixel_offset).write(color);
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    fn swap_buffers(&mut self) -> Result<(), &'static str> {
        Ok(())
    }

    fn supports_mode(&self, mode: &GraphicsMode) -> bool {
        // VBE supports most common modes up to 1920x1200
        mode.width <= 1920 && mode.height <= 1200
    }

    fn pixel_format(&self) -> PixelFormat {
        // Get current mode and determine pixel format from mode info
        if let Some(current_mode) = self.vbe_controller.get_current_mode() {
            if let Ok(mode_info) = self.vbe_controller.get_controller().get_mode_info_details(current_mode) {
                return self.vbe_controller.get_controller().determine_pixel_format(&mode_info);
            }
        }
        // Default to RGB if we can't determine the format
        PixelFormat::RGB
    }
}

/// Create appropriate graphics backend for boot protocol
pub fn create_graphics_backend(
    protocol_type: crate::protocol::BootProtocolType,
) -> Result<Box<dyn GraphicsBackend>, &'static str> {
    match protocol_type {
        #[cfg(feature = "uefi_support")]
        crate::protocol::BootProtocolType::Uefi => Ok(Box::new(UefiGopBackend::new())),

        #[cfg(feature = "bios_support")]
        crate::protocol::BootProtocolType::Bios => Ok(Box::new(VbeBackend::new())),

        #[cfg(not(feature = "uefi_support"))]
        crate::protocol::BootProtocolType::Uefi => Err("UEFI support not compiled"),

        #[cfg(not(feature = "bios_support"))]
        crate::protocol::BootProtocolType::Bios => Err("BIOS support not compiled"),

        crate::protocol::BootProtocolType::Multiboot2 => {
            #[cfg(feature = "bios_support")]
            {
                Ok(Box::new(VbeBackend::new()))
            }
            #[cfg(not(feature = "bios_support"))]
            {
                Err("No graphics backend available for Multiboot2")
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(feature = "bios_support")]
    fn test_vbe_backend_creation() {
        let backend = VbeBackend::new();
        assert!(backend.framebuffer_info.is_none());
        assert!(!backend.initialized);
    }

    #[test]
    #[cfg(feature = "bios_support")]
    fn test_vbe_supports_common_modes() {
        let backend = VbeBackend::new();
        let mode_1024 = GraphicsMode::new(1024, 768, 32).unwrap();
        let mode_1920 = GraphicsMode::new(1920, 1080, 32).unwrap();
        
        assert!(backend.supports_mode(&mode_1024));
        assert!(backend.supports_mode(&mode_1920));
    }
}
